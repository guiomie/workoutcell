{"ts":1339985425112,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"var map;\nvar poly;\nvar distance = 0;\nvar markerArray = [];\nvar latlngArray = []; //only used to calculate altitude\nvar bikeLayer = null;\nvar lastAddedDistance = [];\nvar markerString = \"\";\n\nfunction initialize() {\n\t\n\tbikeLayer = new google.maps.BicyclingLayer();\n\tvar latlng = new google.maps.LatLng(applicationVariables.profile.location.latlng.lat, applicationVariables.profile.location.latlng.lng);\n\tvar myOptions = {\n\t\tzoom: 14,\n\t\tcenter: latlng,\n\t\tmapTypeId: google.maps.MapTypeId.ROADMAP\n\t};\n\t\n\tmap = new google.maps.Map(document.getElementById(\"map_canvas\"),myOptions);\n\t\n\t//Polyline option setters\n\tvar polyOptions = {\n\t\tstrokeColor: '#000000',\n\t\tstrokeOpacity: 1.0,\n\t\tstrokeWeight: 3\n\t}\n    \n\tpoly = new google.maps.Polyline(polyOptions);\n\tpoly.setMap(map);\n\t\n\t// Add a listener for the click event\n\tgoogle.maps.event.addListener(map, 'click', addLatLng);\n    \n    \n    //For cell creation dialog\n    //setAutoComplete();\n}\n\nfunction addLatLng(event) {\n\n\tvar path = poly.getPath();\n\n\t// Because path is an MVCArray, we can simply append a new coordinate\n\t// and it will automatically appear\n\tpath.push(event.latLng);\n\n\tupdateDistance(poly);\n  \n  // Add a new marker at the new plotted point on the polyline.\n  var marker = new google.maps.Marker({\n    position: event.latLng,\n    title: Math.round(distance) + ' meters',\n    map: map\n  });\n  \n  markerArray.push(marker);\n}\n\nfunction setAutoComplete(){\n\n    var input = document.getElementById('cellLocationInput');\n    var options = {\n      types: ['(cities)'],\n      componentRestrictions: {country: 'fr'}\n    };\n    \n    autocomplete = new google.maps.places.Autocomplete(input, options);\n    \n    \n}\n\nfunction updateDistance(poly){\n\tpolypath = poly.getPath();\n\t\n\tif(polypath.getLength() !== 1){\n\t\tvar latLngB = polypath.getAt(polypath.getLength() - 1);\n\t\tvar latLngA = polypath.getAt(polypath.getLength() - 2);\n\t\tvar theDistance = google.maps.geometry.spherical.computeDistanceBetween (latLngA, latLngB);\n        lastAddedDistance.push(Math.round(theDistance*100)/100000);\n        distance = distance + theDistance;\n\t\tdocument.getElementById('distance').innerHTML = Math.round(distance*100)/100000;\n\t\t\n\t}\n\t\n}\n\nfunction undoLast(){\n \n    //Delete last stroke\n    var tempoPathArray = poly.getPath();\n    tempoPathArray.removeAt(tempoPathArray.getLength()-1);\n    poly.setPath(tempoPathArray);  \n    //Delete last marker in global var and on map\n    markerArray[markerArray.length-1].setMap(null);\n    markerArray.pop();\n    //Adjust distance and the pop deletes last element and returns it\n    if(lastAddedDistance.length === 1){\n       clearMap(); \n    }\n    else{\n        var adjustedDistance = document.getElementById('distance').innerHTML - lastAddedDistance.pop();;\n        document.getElementById('distance').innerHTML = Math.round(adjustedDistance*10000)/10000;\n    }\n\n}\n\nfunction clearMap(){\n\t// remove poly from map\n\tpoly.setMap(null);\n\t//delete poly\n\tpoly = null;\n\t\n\t// recreate poly\n\tvar polyOptions = {\n\t\tstrokeColor: '#000000',\n\t\tstrokeOpacity: 1.0,\n\t\tstrokeWeight: 3\n\t}\t\n\tpoly = new google.maps.Polyline(polyOptions);\n\tpoly.setMap(map);\n\tdistance = 0;\n\tdocument.getElementById('distance').innerHTML = Math.round(distance);\t\t\n\t\n\t//clear markers on map\n\tif (markerArray) {\n\t\t//removes markers from map\n        for (i in markerArray) {\n\t\t\tmarkerArray[i].setMap(null);\n\t\t}\n        //removes marker from variable, so they dont end up in next query\n        markerArray = [];\n\t}\n\t//empty array of distances\n    lastAddedDistance = [];\n    latlngArray = [];\n}\n\nfunction markertTitleArray(array, callback){\n    var callbackArray = [];\n    \n    for(i=0; i < array.length; i++){      \n        callbackArray.push(array[i].getTitle());           \n    }\n    \n    callback(callbackArray);         \n}\n\n//This will create proper converted array for database\n//It will also create the marker stirng part of the static image\nfunction markerLatLngArray(array, callback){\n    var callbackArray = [];\n    markerString = \"&markers=label:S%7C\" + array[0].getPosition().lat() + \",\" + array[0].getPosition().lng()\n    + \"&markers=label:F%7C\" + array[array.length-1].getPosition().lat() + \",\" + array[array.length-1].getPosition().lng();\n    \n    for(i=0; i < array.length; i++){\n        callbackArray.push({ lat: array[i].getPosition().lat(), lng: array[i].getPosition().lng()});\n    }\n    callback(callbackArray);\n}\n\n\nfunction loadPolylines(arrayPath){\n    var path = new google.maps.MVCArray();\n    var polyOptions = {\n    \tstrokeColor: '#000000',\n\t\tstrokeOpacity: 1.0,\n\t\tstrokeWeight: 3\n\t}\n    \n    $.each(arrayPath, function(key, val) {\n            path.push(new google.maps.LatLng(val.Pa, val.Qa));\n    })\n    \n    poly = new google.maps.Polyline(polyOptions);\n    poly.setPath(path);\n    poly.setMap(map);\n \n}\n\nfunction decodeToMap(string){\n    \n    var polyOptions = {\n        strokeColor: '#000000',\n\t\tstrokeOpacity: 1.0,\n\t\tstrokeWeight: 3\n\t}\n    \n    poly = new google.maps.Polyline(polyOptions);\n    poly.setPath(google.maps.geometry.encoding.decodePath(string));\n    poly.setMap(map);\n}\n\nfunction loadMarkers(arrayLatLng, arrayTitle){\n\n    //alert(arrayLatLng + \" : \" + arrayTitle);\n    for(i = 0; i < arrayLatLng.length; i++){\n        var pos = new google.maps.LatLng(arrayLatLng[i].lat, arrayLatLng[i].lng);\n        latlngArray.push(pos);\n        var marker = new google.maps.Marker({\n            position: pos,\n            title: JSON.stringify(arrayTitle[i]),\n            map: map\n        });\n        markerArray.push(marker);   \n        \n    }\n\n}\n\n//This will verify if the passed lat lng passed are instantiated\n//If not, it will use a geocoding to return new value\n//This is used to make sure the map is centered at the users location\nfunction setUsersLatLng(location, callback){\n\n    if(location.latlng.lat !== 0){\n        callback('Already instantiated');    \n    }\n    else{\n        var geocoder = new google.maps.Geocoder();\n        \n        geocoder.geocode( { 'address': location.name}, function(results, status) {\n          if (status == google.maps.GeocoderStatus.OK) {\n            //In this case it creates a marker, but you can get the lat and lng from the location.LatLng\n            //alert(JSON.stringify(results));\n            callback({lat: results[0].geometry.location.lat(), lng: results[0].geometry.location.lng()});\n          } else {\n            //alert(\"Geocode was not successful for the following reason: \" + status + ' sent: ' + location.name);\n            callback('Failed');\n          }\n        });\n    }\n}\n\nfunction calculateAltitude(array){\n\n    var elevationService = new google.maps.ElevationService();\n   \n    elevationService.getElevationAlongPath({path: array, samples: 440}, function(elevationResultArray, elevationStatus){\n         //console.log(ElevationResultArray);\n        //alert(ElevationStatus);\n        drawElevationGraph(elevationArrayToArray(elevationResultArray));\n    });\n    \n    \n}"]],"start1":0,"start2":0,"length1":0,"length2":6895}]],"length":6895}
